## **张量**

```python
import torch
import numpy as np

data = [[1,2],[3,4]]
```

### **函数索引**

`torch.tensor(data)`;

`torch.from_numpy(np.array(data))`; 

`torch.ones_like(张量)`;`torch.rand_like(张量)`; 

```
torch.ones(设定好的张量形状shape)`; `torch.rand(shape)`;`torch.zeros(shape)
```

`张量.to('cuda')`;

```
torch.cat([张量,张量,张量], dim=1);
```

运算符`*`; `@ `; `_`

### **张量初始化**

- 直接法

```python
x_data = torch.tensor(data)
```

- numpy array法

```
np_array = np.array(data)
x_np = torch.from_numpy(np_array)
```

- 张量"类似"法

```python
x_ones = torch.ones_like(x_data)
x_ones = torch.rand_like(x_data,dtype = torch.float)
```

- 规定张量形状

```python
shape = (2,3,)
rand_tensor = torch.rand(shape)
ones_tensor = torch.ones(shape)
zeros_tensor = torch.zeros(shape)
```

### **张量属性查看**

```python
tensor = torch.rand(3,4)
print(f"Shape of tensor:{tensor.shape}")
print(f"Datatype of tensor:{tensor.dtype}")
print(f"Device tensor is stored on:{tensor.device}")
```

### **张量GPU操作**

```python
#将张量移至GPU
if torch.cuda.is_available():
    tensor = tensor.to('cuda')
```

### **张量连接**

将张量顺序合成一个张量

```
t1 = torch.cat([tensor,tensor,tensor],dim=1)
```

### **张量相乘**

对应元素相乘，以下两种写法

```
tensor1 * tensor2
tensor1.mul(tensor2)
```

矩阵乘法

```
tensor1.matmul(tensor2.T)
tensor1 @ tensor2.T
```

### 就地操作

```
tensor.add_(5) #张量内元素加5
```